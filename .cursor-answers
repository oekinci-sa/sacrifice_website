Size projenin adım adım planlamasını Türkçe olarak anlatayım:

### 1. Proje Yapısı ve Kurulum
1. Next.js 14 projesi TypeScript ile oluşturulacak
2. Shadcn/ui kurulumu yapılacak
3. Tailwind CSS entegrasyonu
4. Supabase kurulumu ve bağlantısı
5. Klasör yapısının oluşturulması (pages, components, types, lib, utils vb.)

### 2. Veritabanı Tasarımı (Supabase)
1. Tablolar:
   - Kurbanlar (sacrifices)
   - Hissedarlar (shareholders)
   - Kullanıcılar (admins)
   - Yazılar (blog posts)
   - İletişim mesajları (contact messages)

### 3. Temel Altyapı Geliştirmeleri
1. Auth sistemi (admin girişleri için)
2. Layout oluşturulması
   - Public layout
   - Admin layout
3. Responsive tasarım için temel componentler
4. Form validasyon altyapısı (react-hook-form + zod)
5. API route'ları

### 4. Public Sayfalar Geliştirmesi
1. Ana sayfa (/)
2. Hakkımızda (/aboutus)
3. Hisse Al (/hisseal)
   - Kurban seçimi
   - Kişisel bilgi formu
   - Ödeme entegrasyonu
   - SMS doğrulama sistemi
4. Hisse Sorgula (/hissesorgula)
   - Sorgulama formu
   - PDF oluşturma ve indirme
5. Blog sayfası (/yazilar)
6. İletişim sayfası (/contact)

### 5. Admin Panel Geliştirmesi
1. Dashboard (/kurban-admin/general-view)
   - İstatistikler
   - Grafikler
   - Özet bilgiler
2. Kurbanlar yönetimi (/kurban-admin/sacrifices)
   - CRUD işlemleri
   - Filtreleme ve arama
3. Hissedarlar yönetimi (/kurban-admin/shareholders)
   - CRUD işlemleri
   - Filtreleme ve arama
   - Toplu işlemler

### 6. Özel Özellikler
1. SMS gönderim sistemi entegrasyonu
2. PDF oluşturma sistemi
3. Ödeme sistemi entegrasyonu
4. Raporlama sistemi

### 7. Test ve Optimizasyon
1. Unit testler
2. E2E testler
3. Performans optimizasyonu
4. SEO optimizasyonu
5. Mobile-first yaklaşımının kontrolü

### 8. Deployment ve Monitoring
1. Production deployment
2. Error tracking
3. Analytics kurulumu
4. Monitoring araçları entegrasyonu

Bu adımların her biri kendi içinde alt görevlere bölünebilir. Hangi aşamadan başlamak istersiniz?



DB Improvements
2. Veritabanı Düzeyinde Kısıtlamalar
Ödeme Tutarlarının Toplamı:
Hissedarların ödediği toplam tutarın, total_amount ile tutarlı olduğundan emin olun.
Öneri: Veritabanı seviyesinde bir CHECK kısıtlaması ekleyin:
sql
Kodu kopyala
CHECK (paid_amount + remaining_payment = total_amount)
Boş Hisse Sayısı:
sacrifice_animals.empty_share alanı, hissedar eklenip çıkarıldıkça otomatik olarak güncellenmeli.
Öneri: Boş hisse sayısını manuel güncellemek yerine, trigger veya stored procedure ile otomatik hesaplama yapabilirsiniz:
sql
Kodu kopyala
CREATE TRIGGER update_empty_share
AFTER INSERT OR DELETE ON shareholders
FOR EACH ROW
EXECUTE PROCEDURE calculate_empty_share();

CREATE TRIGGER set_timestamp
BEFORE INSERT OR UPDATE ON sacrifice_animals
FOR EACH ROW
EXECUTE FUNCTION set_current_timestamp();


4. Loglama ve Takip
change_logs Tablonuzu Geliştirin:
table_name alanına ek olarak, eski ve yeni değerleri de saklayabilirsiniz. Bu, bir kaydın nasıl değiştirildiğini daha iyi analiz etmenizi sağlar.
Öneri: Yeni bir JSON alan ekleyerek eski ve yeni değerleri kaydedebilirsiniz:
sql
Kodu kopyala
ALTER TABLE change_logs ADD COLUMN old_values JSONB;
ALTER TABLE change_logs ADD COLUMN new_values JSONB;
Tetikleyici ile eski ve yeni verileri kaydedebilirsiniz:
sql
Kodu kopyala
CREATE TRIGGER log_changes
AFTER UPDATE OR DELETE ON sacrifice_animals
FOR EACH ROW
EXECUTE FUNCTION log_record_changes();


5. Performans ve Ölçeklenebilirlik
Sorgu Performansı İçin İndeksleme:
Sıklıkla sorgulanan alanlara indeks ekleyin:
sacrifice_animals.sacrifice_no
shareholders.sacrifice_no
shareholders.phone_number (hızlı arama için).
Öneri: Örnek bir indeks:
sql
Kodu kopyala
CREATE INDEX idx_sacrifice_no ON shareholders (sacrifice_no);

6. Teslimat Ücreti ve Türü
Veritabanında Dinamik Ücretler:
delivery_fee alanını elle doldurmak yerine, delivery_type seçimine göre dinamik olarak hesaplatabilirsiniz.
Öneri: Örneğin, teslimat ücreti için bir sanal alan veya fonksiyon kullanın:
sql
Kodu kopyala
CASE 
  WHEN delivery_type = 'Toplu Teslim Noktası' THEN 500 
  ELSE 0 
END AS delivery_fee


8. Kullanıcı Rolleri ve Güvenlik
Admin Yetkilendirme:
last_edited_by alanı, bir admin ID'si içeriyor gibi görünüyor. Ancak, güvenliği artırmak için adminlerin erişim seviyelerini yönetmek adına bir user_roles tablosu ekleyebilirsiniz.

9. Yedekleme ve Kurtarma
Düzenli Yedekleme Planı:
Özellikle kurban organizasyonu gibi kritik süreçlerde, günlük veya haftalık yedekleme planı oluşturun.
Öneri: pg_dump ile düzenli yedekleme betiği:
bash
Kodu kopyala
pg_dump -U your_username -d your_database -F c -f backup_file_name



#TIMEOUT MECHANISM
Haklısınız, sabit bir süre koymak bazı senaryolarda problem yaratabilir. Kullanıcı formu doldurmayı hızlıca bırakırsa veya sekmeyi kapatırsa, "bekleme süresi" gereksiz yere veritabanındaki hisselerin rezerve edilmiş gibi görünmesine neden olabilir. Bu sorunu çözmek için, **kullanıcı davranışını takip eden bir mekanizma** ile bu durumu gerçek zamanlı olarak algılamak ve çözüm üretmek gerekiyor. İşte bu duruma yönelik alternatif ve daha dinamik bir yaklaşım:

---

### **Çözüm: Kullanıcı Davranışına Dayalı Rezervasyon Kontrolü**
Hisse rezervasyonu sırasında, kullanıcı aktif mi değil mi ve form doldurmayı tamamladı mı gibi durumları kontrol ederek, rezervasyonu gerçek zamanlı olarak güncelleyebilirsiniz.

#### 1. **Kullanıcı Aktivitesi Takibi (Heartbeat Mekanizması)**
Kullanıcı formu doldururken veya rezervasyon ekranındayken, backend’e düzenli olarak bir "heartbeat" sinyali gönderilir. Eğer backend’e belirli bir süre boyunca bu sinyal ulaşmazsa (örneğin 1 dakika), rezervasyon iptal edilir.

- **Nasıl Çalışır?**
  - Kullanıcı hisse seçip form doldurmaya başlar.
  - Frontend, her 30 saniyede bir backend’e "Kullanıcı hala aktif mi?" mesajını gönderir.
  - Backend, bu aktiviteyi izleyerek rezervasyonu açık tutar. 
  - Eğer belirli bir süre (ör. 60 saniye) boyunca heartbeat alınmazsa, rezervasyon iptal edilir ve hisseler tekrar boş görünür.

**Frontend (JavaScript) Örneği:**
```javascript
let heartbeatInterval;

function startHeartbeat(reservationId) {
  heartbeatInterval = setInterval(() => {
    fetch(`/api/heartbeat`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ reservationId })
    });
  }, 30000); // Her 30 saniyede bir heartbeat gönder
}

function stopHeartbeat() {
  clearInterval(heartbeatInterval);
}

// Kullanıcı form sayfasını terk ettiğinde veya sekmeyi kapattığında
window.addEventListener("beforeunload", stopHeartbeat);
```

**Backend (Node.js veya benzeri) Örneği:**
```javascript
let activeReservations = {}; // Aktif rezervasyonları takip etmek için

// Heartbeat API
app.post("/api/heartbeat", (req, res) => {
  const { reservationId } = req.body;
  if (activeReservations[reservationId]) {
    activeReservations[reservationId].lastHeartbeat = Date.now();
    res.sendStatus(200);
  } else {
    res.sendStatus(404); // Rezervasyon bulunamadı
  }
});

// Rezervasyon Temizleme
setInterval(() => {
  const now = Date.now();
  for (const reservationId in activeReservations) {
    if (now - activeReservations[reservationId].lastHeartbeat > 60000) {
      // 60 saniyeden uzun süre heartbeat yoksa rezervasyonu iptal et
      cancelReservation(reservationId);
      delete activeReservations[reservationId];
    }
  }
}, 30000);
```

---

#### 2. **Sekme veya Sayfa Değişikliğini Algılama**
Kullanıcı sekmeyi kapatırsa veya başka bir sayfaya geçerse, bu durumu algılayarak rezervasyonu hemen iptal edebilirsiniz.

- **Frontend'de `visibilitychange` Event'i Kullanma:**
```javascript
document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "hidden") {
    stopHeartbeat(); // Kullanıcı sayfadan ayrıldı
    fetch(`/api/cancelReservation`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ reservationId })
    });
  }
});
```

---

#### 3. **Veritabanında Rezervasyon İşlemleri**
Rezervasyon sürecini ve iptalleri dinamik olarak yönetmek için şu adımları izleyebilirsiniz:

- Kullanıcı formu doldurmaya başlarken bir rezervasyon oluşturulur:
```sql
INSERT INTO share_reservations (sacrifice_no, reserved_shares, reserved_by, reserved_at)
VALUES ($sacrifice_no, $reserved_shares, $user_id, NOW());
```

- Kullanıcı aktif olduğu sürece rezervasyon güncellenir (heartbeat aracılığıyla):
```sql
UPDATE share_reservations
SET reserved_at = NOW()
WHERE reservation_id = $reservation_id;
```

- Kullanıcı formu doldurmayı bırakırsa veya sekmeyi kapatırsa rezervasyon iptal edilir:
```sql
DELETE FROM share_reservations
WHERE reservation_id = $reservation_id;
```

---

#### 4. **Backend'de Rezervasyonların Temizlenmesi**
Backend tarafında, **heartbeat alınmayan rezervasyonları iptal etmek** için düzenli bir kontrol işlemi çalıştırabilirsiniz. Bu işlem, rezervasyonun otomatik olarak kaldırılmasını sağlar.

**Heartbeat Kontrol Mekanizması:**
```sql
DELETE FROM share_reservations
WHERE NOW() - reserved_at > INTERVAL '1 minute';
```

---

### **Avantajlar:**
1. **Dinamik Yönetim:** Kullanıcı gerçekten aktif olmadığında rezervasyon otomatik olarak serbest bırakılır.
2. **Gerçek Zamanlı Güncelleme:** Hisse bilgisi her zaman doğru tutulur, sabit bir süreye bağlı kalınmaz.
3. **Daha Az Bekleme:** Kullanıcı hızlıca vazgeçerse hisseler hemen serbest kalır, başka bir kullanıcı hisseyi seçebilir.

### **Sonuç:**
Bu çözüm, kullanıcı davranışını gerçek zamanlı olarak izleyerek rezervasyonların doğru ve tutarlı bir şekilde yönetilmesini sağlar. Hem backend hem de frontend tarafında, sekme kapatma veya aktivitesizlik durumlarını ele alarak veritabanında gereksiz "rezerve edilmiş" gibi görünen hisseleri önlersiniz.